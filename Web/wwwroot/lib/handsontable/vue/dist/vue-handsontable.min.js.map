{"version":3,"file":"vue-handsontable.min.js","sources":["../src/helpers.ts","../src/lib/lru/lru.js","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../src/HotTable.vue","../node_modules/vue-class-component/dist/vue-class-component.esm.js"],"sourcesContent":["import Vue, { VNode } from 'vue';\nimport Handsontable from 'handsontable';\nimport { HotTableProps, VueProps, EditorComponent } from './types';\n\nconst unassignedPropSymbol = Symbol('unassigned');\nlet bulkComponentContainer = null;\n\n/**\n * Rewrite the settings object passed to the watchers to be a clean array/object prepared to use within Handsontable config.\n *\n * @param {*} observerSettings Watcher object containing the changed data.\n * @returns {Object|Array}\n */\nexport function rewriteSettings(observerSettings): any[] | object {\n  const settingsType = Object.prototype.toString.call(observerSettings);\n  let settings: any[] | object | null = null;\n  let type: { array?: boolean, object?: boolean } = {};\n\n  if (settingsType === '[object Array]') {\n    settings = [];\n    type.array = true;\n\n  } else if (settingsType === '[object Object]') {\n    settings = {};\n    type.object = true;\n  }\n\n  if (type.array || type.object) {\n    for (const p in observerSettings) {\n      if (observerSettings.hasOwnProperty(p)) {\n        settings[p] = observerSettings[p];\n      }\n    }\n\n  } else {\n    settings = observerSettings;\n  }\n\n  return settings;\n}\n\n/**\n * Private method to ensure the table is not calling `updateSettings` after editing cells.\n * @private\n */\nexport function preventInternalEditWatch(component) {\n  component.hotInstance.addHook('beforeChange', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeCreateRow', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeCreateCol', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeRemoveRow', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeRemoveCol', () => {\n    component.__internalEdit = true;\n  });\n}\n\n/**\n * Generate an object containing all the available Handsontable properties and plugin hooks.\n *\n * @param {String} source Source for the factory (either 'HotTable' or 'HotColumn').\n * @returns {Object}\n */\nexport function propFactory(source): VueProps<HotTableProps> {\n  const registeredHooks: string[] = Handsontable.hooks.getRegistered();\n\n  let propSchema: VueProps<HotTableProps> = {};\n  Object.assign(propSchema, Handsontable.DefaultSettings);\n\n  for (let prop in propSchema) {\n    propSchema[prop] = {\n      default: unassignedPropSymbol\n    };\n  }\n\n  for (let i = 0; i < registeredHooks.length; i++) {\n    propSchema[registeredHooks[i]] = {\n      default: unassignedPropSymbol\n    };\n  }\n\n  propSchema.settings = {\n    default: unassignedPropSymbol\n  };\n\n  if (source === 'HotTable') {\n    propSchema.id = {\n      type: String,\n      default: 'hot-' + Math.random().toString(36).substring(5)\n    };\n\n    propSchema.wrapperRendererCacheSize = {\n      type: Number,\n      default: 3000\n    };\n  }\n\n  return propSchema;\n}\n\n/**\n * Filter out all of the unassigned props, and return only the one passed to the component.\n *\n * @param {Object} props Object containing all the possible props.\n * @returns {Object} Object containing only used props.\n */\nexport function filterPassedProps(props) {\n  const filteredProps: VueProps<HotTableProps> = {};\n  const columnSettingsProp = props['settings'];\n\n  if (columnSettingsProp !== unassignedPropSymbol) {\n    for (let propName in columnSettingsProp) {\n      if (columnSettingsProp.hasOwnProperty(propName) && columnSettingsProp[propName] !== unassignedPropSymbol) {\n        filteredProps[propName] = columnSettingsProp[propName];\n      }\n    }\n  }\n\n  for (let propName in props) {\n    if (props.hasOwnProperty(propName) && propName !== 'settings' && props[propName] !== unassignedPropSymbol) {\n      filteredProps[propName] = props[propName];\n    }\n  }\n\n  return filteredProps;\n}\n\n/**\n * Prepare the settings object to be used as the settings for Handsontable, based on the props provided to the component.\n *\n * @param {HotTableProps} props The props passed to the component.\n * @param {Handsontable.GridSettings} currentSettings The current Handsontable settings.\n * @returns {Handsontable.GridSettings} An object containing the properties, ready to be used within Handsontable.\n */\nexport function prepareSettings(props: HotTableProps, currentSettings?: Handsontable.GridSettings): Handsontable.GridSettings {\n  const assignedProps: VueProps<HotTableProps> = filterPassedProps(props);\n  const hotSettingsInProps: {} = props.settings ? props.settings : assignedProps;\n  const additionalHotSettingsInProps: Handsontable.GridSettings = props.settings ? assignedProps : null;\n  const newSettings = {};\n\n  for (const key in hotSettingsInProps) {\n    if (\n      hotSettingsInProps.hasOwnProperty(key) &&\n      hotSettingsInProps[key] !== void 0 &&\n      ((currentSettings && key !== 'data') ? !simpleEqual(currentSettings[key], hotSettingsInProps[key]) : true)\n    ) {\n      newSettings[key] = hotSettingsInProps[key];\n    }\n  }\n\n  for (const key in additionalHotSettingsInProps) {\n    if (\n      additionalHotSettingsInProps.hasOwnProperty(key) &&\n      key !== 'id' &&\n      key !== 'settings' &&\n      key !== 'wrapperRendererCacheSize' &&\n      additionalHotSettingsInProps[key] !== void 0 &&\n      ((currentSettings && key !== 'data') ? !simpleEqual(currentSettings[key], additionalHotSettingsInProps[key]) : true)\n    ) {\n      newSettings[key] = additionalHotSettingsInProps[key];\n    }\n  }\n\n  return newSettings;\n}\n\n/**\n * Get the VNode element with the provided type attribute from the component slots.\n *\n * @param {Array} componentSlots Array of slots from a component.\n * @param {String} type Type of the child component. Either `hot-renderer` or `hot-editor`.\n * @returns {Object|null} The VNode of the child component (or `null` when nothing's found).\n */\nexport function findVNodeByType(componentSlots: VNode[], type: string): VNode {\n  let componentVNode: VNode = null;\n\n  componentSlots.every((slot, index) => {\n    if (slot.data && slot.data.attrs && slot.data.attrs[type] !== void 0) {\n      componentVNode = slot;\n      return false;\n    }\n\n    return true;\n  });\n\n  return componentVNode;\n}\n\n/**\n * Get all `hot-column` component instances from the provided children array.\n *\n * @param {Array} children Array of children from a component.\n * @returns {Array} Array of `hot-column` instances.\n */\nexport function getHotColumnComponents(children) {\n  return children.filter((child) => child.$options.name === 'HotColumn');\n}\n\n/**\n * Create an instance of the Vue Component based on the provided VNode.\n *\n * @param {Object} vNode VNode element to be turned into a component instance.\n * @param {Object} parent Instance of the component to be marked as a parent of the newly created instance.\n * @param {Object} props Props to be passed to the new instance.\n * @param {Object} data Data to be passed to the new instance.\n */\nexport function createVueComponent(vNode: VNode, parent: Vue, props: object, data: object): EditorComponent {\n  const ownerDocument = parent.$el ? parent.$el.ownerDocument : document;\n  const settings: object = {\n    propsData: props,\n    parent,\n    data\n  };\n\n  if (!bulkComponentContainer) {\n    bulkComponentContainer = ownerDocument.createElement('DIV');\n    bulkComponentContainer.id = 'vueHotComponents';\n\n    ownerDocument.body.appendChild(bulkComponentContainer);\n  }\n\n  const componentContainer = ownerDocument.createElement('DIV');\n  bulkComponentContainer.appendChild(componentContainer);\n\n  return (new (vNode.componentOptions as any).Ctor(settings)).$mount(componentContainer);\n}\n\n/**\n * Compare two objects using `JSON.stringify`.\n * *Note: * As it's using the stringify function to compare objects, the property order in both objects is\n * important. It will return `false` for the same objects, if they're defined in a different order.\n *\n * @param {object} objectA First object to compare.\n * @param {object} objectB Second object to compare.\n * @returns {boolean} `true` if they're the same, `false` otherwise.\n */\nfunction simpleEqual(objectA, objectB) {\n  return JSON.stringify(objectA) === JSON.stringify(objectB);\n}\n","/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n(function(g,f){\n  const e = typeof exports == 'object' ? exports : typeof g == 'object' ? g : {};\n  f(e);\n  if (typeof define == 'function' && define.amd) { define('lru', e); }\n})(this, function(exports) {\n\n  const NEWER = Symbol('newer');\n  const OLDER = Symbol('older');\n\n  function LRUMap(limit, entries) {\n    if (typeof limit !== 'number') {\n      // called as (entries)\n      entries = limit;\n      limit = 0;\n    }\n\n    this.size = 0;\n    this.limit = limit;\n    this.oldest = this.newest = undefined;\n    this._keymap = new Map();\n\n    if (entries) {\n      this.assign(entries);\n      if (limit < 1) {\n        this.limit = this.size;\n      }\n    }\n  }\n\n  exports.LRUMap = LRUMap;\n\n  function Entry(key, value) {\n    this.key = key;\n    this.value = value;\n    this[NEWER] = undefined;\n    this[OLDER] = undefined;\n  }\n\n\n  LRUMap.prototype._markEntryAsUsed = function(entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER];\n      }\n      entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n    }\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n    }\n    entry[NEWER] = undefined; // D --x\n    entry[OLDER] = this.newest; // D. --> E\n    if (this.newest) {\n      this.newest[NEWER] = entry; // E. <-- D\n    }\n    this.newest = entry;\n  };\n\n  LRUMap.prototype.assign = function(entries) {\n    let entry, limit = this.limit || Number.MAX_VALUE;\n    this._keymap.clear();\n    let it = entries[Symbol.iterator]();\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = new Entry(itv.value[0], itv.value[1]);\n      this._keymap.set(e.key, e);\n      if (!entry) {\n        this.oldest = e;\n      } else {\n        entry[NEWER] = e;\n        e[OLDER] = entry;\n      }\n      entry = e;\n      if (limit-- == 0) {\n        throw new Error('overflow');\n      }\n    }\n    this.newest = entry;\n    this.size = this._keymap.size;\n  };\n\n  LRUMap.prototype.get = function(key) {\n    // First, find our cache entry\n    var entry = this._keymap.get(key);\n    if (!entry) return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    this._markEntryAsUsed(entry);\n    return entry.value;\n  };\n\n  LRUMap.prototype.set = function(key, value) {\n    var entry = this._keymap.get(key);\n\n    if (entry) {\n      // update existing\n      entry.value = value;\n      this._markEntryAsUsed(entry);\n      return this;\n    }\n\n    // new entry\n    this._keymap.set(key, (entry = new Entry(key, value)));\n\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry;\n      entry[OLDER] = this.newest;\n    } else {\n      // we're first in -- yay\n      this.oldest = entry;\n    }\n\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.newest = entry;\n    ++this.size;\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift();\n    }\n\n    return this;\n  };\n\n  LRUMap.prototype.shift = function() {\n    // todo: handle special case when limit == 1\n    var entry = this.oldest;\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER];\n        this.oldest[OLDER] = undefined;\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined;\n        this.newest = undefined;\n      }\n      // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n      entry[NEWER] = entry[OLDER] = undefined;\n      this._keymap.delete(entry.key);\n      --this.size;\n      return [entry.key, entry.value];\n    }\n  };\n\n// ----------------------------------------------------------------------------\n// Following code is optional and can be removed without breaking the core\n// functionality.\n  LRUMap.prototype.has = function(key) {\n    return this._keymap.has(key);\n  };\n});\n","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","<template>\n  <div :id=\"id\">\n    <slot></slot>\n  </div>\n</template>\n\n<script lang=\"ts\">\n  import {\n    propFactory,\n    preventInternalEditWatch,\n    prepareSettings,\n    createVueComponent,\n    findVNodeByType,\n    getHotColumnComponents\n  } from './helpers';\n  import Vue, { VNode } from 'vue';\n  import {\n    HotTableData,\n    HotTableMethods,\n    HotTableProps,\n    HotTableComponent,\n    EditorComponent\n  } from './types';\n  import * as packageJson from '../package.json';\n  import { LRUMap } from './lib/lru/lru';\n  import Handsontable from 'handsontable';\n\n  const HotTable: HotTableComponent<Vue, HotTableData, HotTableMethods, {}, HotTableProps> = {\n    name: 'HotTable',\n    props: propFactory('HotTable'),\n    watch: {\n      mergedHotSettings: function (value) {\n        if (value.data) {\n          if (\n            this.hotInstance.isColumnModificationAllowed() ||\n            (\n              !this.hotInstance.isColumnModificationAllowed() &&\n              this.hotInstance.countSourceCols() === this.miscCache.currentSourceColumns\n            )\n          ) {\n            // If the dataset dimensions change, update the index mappers.\n            this.matchHotMappersSize(value.data);\n\n            // Data is automatically synchronized by reference.\n            delete value.data;\n          }\n        }\n\n        // If there are another options changed, update the HOT settings, render the table otherwise.\n        if (Object.keys(value).length) {\n          this.hotInstance.updateSettings(value);\n\n        } else {\n          this.hotInstance.render();\n        }\n\n        this.miscCache.currentSourceColumns = this.hotInstance.countSourceCols();\n      }\n    },\n    data: function () {\n      const rendererCache = new LRUMap(this.wrapperRendererCacheSize);\n\n      // Make the LRU cache destroy each removed component\n      rendererCache.shift = function () {\n        let entry = LRUMap.prototype.shift.call(this);\n        entry[1].component.$destroy();\n\n        return entry;\n      };\n\n      return {\n        __internalEdit: false,\n        miscCache: {\n          currentSourceColumns: null\n        },\n        hotInstance: null,\n        columnSettings: null,\n        rendererCache: rendererCache,\n        editorCache: new Map()\n      };\n    },\n    computed: {\n      mergedHotSettings: function (): Handsontable.GridSettings {\n        return prepareSettings(this.$props, this.hotInstance ? this.hotInstance.getSettings() : void 0);\n      }\n    },\n    methods: {\n      /**\n       * Initialize Handsontable.\n       */\n      hotInit: function (): void {\n        const globalRendererVNode = this.getGlobalRendererVNode();\n        const globalEditorVNode = this.getGlobalEditorVNode();\n\n        const newSettings: Handsontable.GridSettings = prepareSettings(this.$props);\n\n        newSettings.columns = this.columnSettings ? this.columnSettings : newSettings.columns;\n\n        if (globalEditorVNode) {\n          newSettings.editor = this.getEditorClass(globalEditorVNode, this);\n\n          globalEditorVNode.child.$destroy();\n        }\n\n        if (globalRendererVNode) {\n          newSettings.renderer = this.getRendererWrapper(globalRendererVNode, this);\n\n          globalRendererVNode.child.$destroy();\n        }\n\n        this.hotInstance = new Handsontable.Core(this.$el, newSettings);\n        this.hotInstance.init();\n\n        preventInternalEditWatch(this);\n\n        this.miscCache.currentSourceColumns = this.hotInstance.countSourceCols();\n      },\n      matchHotMappersSize: function (data: any[][]): void {\n        const rowsToRemove: number[] = [];\n        const columnsToRemove: number[] = [];\n        const indexMapperRowCount = this.hotInstance.rowIndexMapper.getNumberOfIndexes();\n        const isColumnModificationAllowed = this.hotInstance.isColumnModificationAllowed();\n        let indexMapperColumnCount = 0;\n\n        if (data && data.length !== indexMapperRowCount) {\n          if (data.length < indexMapperRowCount) {\n            for (let r = data.length; r < indexMapperRowCount; r++) {\n              rowsToRemove.push(r);\n            }\n          }\n        }\n\n        if (isColumnModificationAllowed) {\n          indexMapperColumnCount = this.hotInstance.columnIndexMapper.getNumberOfIndexes();\n\n          if (data && data[0] && data[0]?.length !==\n            indexMapperColumnCount) {\n            if (data[0].length < indexMapperColumnCount) {\n              for (let c = data[0].length; c < indexMapperColumnCount; c++) {\n                columnsToRemove.push(c);\n              }\n            }\n          }\n        }\n\n        this.hotInstance.batch(() => {\n          if (rowsToRemove.length > 0) {\n            this.hotInstance.rowIndexMapper.removeIndexes(rowsToRemove);\n\n          } else {\n            this.hotInstance.rowIndexMapper.insertIndexes(indexMapperRowCount - 1, data.length - indexMapperRowCount);\n          }\n\n          if (isColumnModificationAllowed) {\n            if (columnsToRemove.length > 0) {\n              this.hotInstance.columnIndexMapper.removeIndexes(columnsToRemove);\n\n            } else {\n              this.hotInstance.columnIndexMapper.insertIndexes(indexMapperColumnCount - 1, data[0].length - indexMapperColumnCount);\n            }\n          }\n        });\n      },\n      getGlobalRendererVNode: function (): VNode | null {\n        const hotTableSlots: VNode[] = this.$slots.default || [];\n        return findVNodeByType(hotTableSlots, 'hot-renderer');\n      },\n      getGlobalEditorVNode: function (): VNode | null {\n        const hotTableSlots: VNode[] = this.$slots.default || [];\n        return findVNodeByType(hotTableSlots, 'hot-editor');\n      },\n      /**\n       * Get settings for the columns provided in the `hot-column` components.\n       */\n      getColumnSettings: function (): HotTableProps[] | void {\n        const hotColumns = getHotColumnComponents(this.$children);\n        let usesRendererComponent = false;\n        let columnSettings: HotTableProps[] = hotColumns.map((elem) => {\n          if (elem.usesRendererComponent) {\n            usesRendererComponent = true;\n          }\n\n          return {...elem.columnSettings};\n        });\n\n        if (usesRendererComponent &&\n          (this.settings && (this.settings.autoColumnSize !== false || this.settings.autoRowSize)) &&\n          (this.autoColumnSize !== false || this.autoRowSize)) {\n          console.warn('Your `hot-table` configuration includes both `hot-column` and `autoRowSize`/`autoColumnSize`, which are not compatible with each other ' +\n            'in this version of `@handsontable/vue`. Disable `autoRowSize` and `autoColumnSize` to prevent row and column misalignment.')\n        }\n\n        return columnSettings.length ? columnSettings : void 0;\n      },\n      /**\n       * Create the wrapper function for the provided renderer child component.\n       *\n       * @param {Object} vNode VNode of the renderer child component.\n       * @param {Boolean} containerComponent Instance of the component, which will be treated as a parent for the newly created renderer component.\n       * @returns {Function} The wrapper function used as the renderer.\n       */\n      getRendererWrapper: function (vNode: VNode, containerComponent: Vue): (...args) => HTMLElement {\n        const $vm = this;\n\n        return function (instance, TD, row, col, prop, value, cellProperties) {\n          // Prevent caching and rendering of the GhostTable table cells\n          if (TD && !TD.getAttribute('ghost-table')) {\n            const rendererCache = $vm.rendererCache;\n            const rendererArgs: object = {\n              hotInstance: instance,\n              TD,\n              row,\n              col,\n              prop,\n              value,\n              cellProperties,\n              isRenderer: true\n            };\n\n            if (rendererCache && !rendererCache.has(`${row}-${col}`)) {\n              const mountedComponent: Vue = createVueComponent(vNode, containerComponent, vNode.componentOptions.propsData, rendererArgs);\n\n              rendererCache.set(`${row}-${col}`, {\n                component: mountedComponent,\n                lastUsedTD: null\n              });\n            }\n\n            const cachedEntry = rendererCache.get(`${row}-${col}`);\n            const cachedComponent: Vue = cachedEntry.component;\n            const cachedTD: HTMLTableCellElement = cachedEntry.lastUsedTD;\n\n            Object.assign(cachedComponent.$data, rendererArgs);\n\n            if (!cachedComponent.$el.parentElement || cachedTD !== TD) {\n              // Clear the previous contents of a TD\n              while (TD.firstChild) {\n                TD.removeChild(TD.firstChild);\n              }\n\n              TD.appendChild(cachedComponent.$el);\n\n              cachedEntry.lastUsedTD = TD;\n            }\n          }\n\n          return TD;\n        };\n      },\n      /**\n       * Create a fresh class to be used as an editor, based on the editor component provided.\n       *\n       * @param {Object} vNode VNode for the editor child component.\n       * @param {Boolean} containerComponent Instance of the component, which will be treated as a parent for the newly created editor component.\n       * @returns {Class} The class used as an editor in Handsontable.\n       */\n      getEditorClass: function (vNode: VNode, containerComponent: Vue): typeof Handsontable.editors.BaseEditor {\n        const componentName: string = (vNode.componentOptions.Ctor as any).options.name;\n        const editorCache = this.editorCache;\n        let mountedComponent: EditorComponent = null;\n\n        if (!editorCache.has(componentName)) {\n          mountedComponent = createVueComponent(vNode, containerComponent, vNode.componentOptions.propsData, {isEditor: true});\n\n          editorCache.set(componentName, mountedComponent);\n\n        } else {\n          mountedComponent = editorCache.get(componentName);\n        }\n\n        return mountedComponent.$data.hotCustomEditorClass;\n      },\n    },\n    mounted: function () {\n      this.columnSettings = this.getColumnSettings();\n\n      return this.hotInit();\n    },\n    beforeDestroy: function () {\n      this.hotInstance.destroy();\n    },\n    version: (packageJson as any).version\n  };\n\n  export default HotTable;\n  export { HotTable };\n</script>\n","/**\n  * vue-class-component v7.2.5\n  * (c) 2015-present Evan You\n  * @license MIT\n  */\nimport Vue from 'vue';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\n// The rational behind the verbose Reflect-feature check below is the fact that there are polyfills\n// which add an implementation for Reflect.defineMetadata but not for Reflect.getOwnMetadataKeys.\n// Without this check consumers will encounter hard to track down runtime errors.\nfunction reflectionIsSupported() {\n  return typeof Reflect !== 'undefined' && Reflect.defineMetadata && Reflect.getOwnMetadataKeys;\n}\nfunction copyReflectionMetadata(to, from) {\n  forwardMetadata(to, from);\n  Object.getOwnPropertyNames(from.prototype).forEach(function (key) {\n    forwardMetadata(to.prototype, from.prototype, key);\n  });\n  Object.getOwnPropertyNames(from).forEach(function (key) {\n    forwardMetadata(to, from, key);\n  });\n}\n\nfunction forwardMetadata(to, from, propertyKey) {\n  var metaKeys = propertyKey ? Reflect.getOwnMetadataKeys(from, propertyKey) : Reflect.getOwnMetadataKeys(from);\n  metaKeys.forEach(function (metaKey) {\n    var metadata = propertyKey ? Reflect.getOwnMetadata(metaKey, from, propertyKey) : Reflect.getOwnMetadata(metaKey, from);\n\n    if (propertyKey) {\n      Reflect.defineMetadata(metaKey, metadata, to, propertyKey);\n    } else {\n      Reflect.defineMetadata(metaKey, metadata, to);\n    }\n  });\n}\n\nvar fakeArray = {\n  __proto__: []\n};\nvar hasProto = fakeArray instanceof Array;\nfunction createDecorator(factory) {\n  return function (target, key, index) {\n    var Ctor = typeof target === 'function' ? target : target.constructor;\n\n    if (!Ctor.__decorators__) {\n      Ctor.__decorators__ = [];\n    }\n\n    if (typeof index !== 'number') {\n      index = undefined;\n    }\n\n    Ctor.__decorators__.push(function (options) {\n      return factory(options, key, index);\n    });\n  };\n}\nfunction mixins() {\n  for (var _len = arguments.length, Ctors = new Array(_len), _key = 0; _key < _len; _key++) {\n    Ctors[_key] = arguments[_key];\n  }\n\n  return Vue.extend({\n    mixins: Ctors\n  });\n}\nfunction isPrimitive(value) {\n  var type = _typeof(value);\n\n  return value == null || type !== 'object' && type !== 'function';\n}\nfunction warn(message) {\n  if (typeof console !== 'undefined') {\n    console.warn('[vue-class-component] ' + message);\n  }\n}\n\nfunction collectDataFromConstructor(vm, Component) {\n  // override _init to prevent to init as Vue instance\n  var originalInit = Component.prototype._init;\n\n  Component.prototype._init = function () {\n    var _this = this;\n\n    // proxy to actual vm\n    var keys = Object.getOwnPropertyNames(vm); // 2.2.0 compat (props are no longer exposed as self properties)\n\n    if (vm.$options.props) {\n      for (var key in vm.$options.props) {\n        if (!vm.hasOwnProperty(key)) {\n          keys.push(key);\n        }\n      }\n    }\n\n    keys.forEach(function (key) {\n      Object.defineProperty(_this, key, {\n        get: function get() {\n          return vm[key];\n        },\n        set: function set(value) {\n          vm[key] = value;\n        },\n        configurable: true\n      });\n    });\n  }; // should be acquired class property values\n\n\n  var data = new Component(); // restore original _init to avoid memory leak (#209)\n\n  Component.prototype._init = originalInit; // create plain data object\n\n  var plainData = {};\n  Object.keys(data).forEach(function (key) {\n    if (data[key] !== undefined) {\n      plainData[key] = data[key];\n    }\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!(Component.prototype instanceof Vue) && Object.keys(plainData).length > 0) {\n      warn('Component class must inherit Vue or its descendant class ' + 'when class property is used.');\n    }\n  }\n\n  return plainData;\n}\n\nvar $internalHooks = ['data', 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeDestroy', 'destroyed', 'beforeUpdate', 'updated', 'activated', 'deactivated', 'render', 'errorCaptured', 'serverPrefetch' // 2.6\n];\nfunction componentFactory(Component) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options.name = options.name || Component._componentTag || Component.name; // prototype props.\n\n  var proto = Component.prototype;\n  Object.getOwnPropertyNames(proto).forEach(function (key) {\n    if (key === 'constructor') {\n      return;\n    } // hooks\n\n\n    if ($internalHooks.indexOf(key) > -1) {\n      options[key] = proto[key];\n      return;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(proto, key);\n\n    if (descriptor.value !== void 0) {\n      // methods\n      if (typeof descriptor.value === 'function') {\n        (options.methods || (options.methods = {}))[key] = descriptor.value;\n      } else {\n        // typescript decorated data\n        (options.mixins || (options.mixins = [])).push({\n          data: function data() {\n            return _defineProperty({}, key, descriptor.value);\n          }\n        });\n      }\n    } else if (descriptor.get || descriptor.set) {\n      // computed properties\n      (options.computed || (options.computed = {}))[key] = {\n        get: descriptor.get,\n        set: descriptor.set\n      };\n    }\n  });\n  (options.mixins || (options.mixins = [])).push({\n    data: function data() {\n      return collectDataFromConstructor(this, Component);\n    }\n  }); // decorate options\n\n  var decorators = Component.__decorators__;\n\n  if (decorators) {\n    decorators.forEach(function (fn) {\n      return fn(options);\n    });\n    delete Component.__decorators__;\n  } // find super\n\n\n  var superProto = Object.getPrototypeOf(Component.prototype);\n  var Super = superProto instanceof Vue ? superProto.constructor : Vue;\n  var Extended = Super.extend(options);\n  forwardStaticMembers(Extended, Component, Super);\n\n  if (reflectionIsSupported()) {\n    copyReflectionMetadata(Extended, Component);\n  }\n\n  return Extended;\n}\nvar reservedPropertyNames = [// Unique id\n'cid', // Super Vue constructor\n'super', // Component options that will be used by the component\n'options', 'superOptions', 'extendOptions', 'sealedOptions', // Private assets\n'component', 'directive', 'filter'];\nvar shouldIgnore = {\n  prototype: true,\n  arguments: true,\n  callee: true,\n  caller: true\n};\n\nfunction forwardStaticMembers(Extended, Original, Super) {\n  // We have to use getOwnPropertyNames since Babel registers methods as non-enumerable\n  Object.getOwnPropertyNames(Original).forEach(function (key) {\n    // Skip the properties that should not be overwritten\n    if (shouldIgnore[key]) {\n      return;\n    } // Some browsers does not allow reconfigure built-in properties\n\n\n    var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);\n\n    if (extendedDescriptor && !extendedDescriptor.configurable) {\n      return;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(Original, key); // If the user agent does not support `__proto__` or its family (IE <= 10),\n    // the sub class properties may be inherited properties from the super class in TypeScript.\n    // We need to exclude such properties to prevent to overwrite\n    // the component options object which stored on the extended constructor (See #192).\n    // If the value is a referenced value (object or function),\n    // we can check equality of them and exclude it if they have the same reference.\n    // If it is a primitive value, it will be forwarded for safety.\n\n    if (!hasProto) {\n      // Only `cid` is explicitly exluded from property forwarding\n      // because we cannot detect whether it is a inherited property or not\n      // on the no `__proto__` environment even though the property is reserved.\n      if (key === 'cid') {\n        return;\n      }\n\n      var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);\n\n      if (!isPrimitive(descriptor.value) && superDescriptor && superDescriptor.value === descriptor.value) {\n        return;\n      }\n    } // Warn if the users manually declare reserved properties\n\n\n    if (process.env.NODE_ENV !== 'production' && reservedPropertyNames.indexOf(key) >= 0) {\n      warn(\"Static property name '\".concat(key, \"' declared on class '\").concat(Original.name, \"' \") + 'conflicts with reserved property name of Vue internal. ' + 'It may cause unexpected behavior of the component. Consider renaming the property.');\n    }\n\n    Object.defineProperty(Extended, key, descriptor);\n  });\n}\n\nfunction Component(options) {\n  if (typeof options === 'function') {\n    return componentFactory(options);\n  }\n\n  return function (Component) {\n    return componentFactory(Component, options);\n  };\n}\n\nComponent.registerHooks = function registerHooks(keys) {\n  $internalHooks.push.apply($internalHooks, _toConsumableArray(keys));\n};\n\nexport default Component;\nexport { createDecorator, mixins };\n"],"names":["unassignedPropSymbol","Symbol","bulkComponentContainer","propFactory","source","registeredHooks","Handsontable","hooks","getRegistered","propSchema","prop","Object","assign","DefaultSettings","i","length","settings","id","type","String","Math","random","toString","substring","wrapperRendererCacheSize","Number","filterPassedProps","props","filteredProps","columnSettingsProp","propName","hasOwnProperty","prepareSettings","currentSettings","assignedProps","hotSettingsInProps","additionalHotSettingsInProps","newSettings","key","simpleEqual","findVNodeByType","componentSlots","componentVNode","every","slot","index","data","attrs","createVueComponent","vNode","parent","ownerDocument","$el","document","propsData","createElement","body","appendChild","componentContainer","componentOptions","Ctor","$mount","objectA","objectB","JSON","stringify","exports","NEWER","OLDER","LRUMap","limit","entries","size","oldest","this","newest","undefined","_keymap","Map","Entry","value","prototype","_markEntryAsUsed","entry","MAX_VALUE","clear","it","iterator","itv","next","done","e","set","Error","get","shift","has","f","component","hotInstance","addHook","__internalEdit","filter","child","$options","name","normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","options","hook","render","staticRenderFns","_compiled","functional","_scopeId","context","$vnode","ssrContext","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","_ssrRegister","$root","shadowRoot","originalRender","h","existing","beforeCreate","concat","_typeof","obj","constructor","_defineProperty","defineProperty","enumerable","configurable","writable","_toConsumableArray","arr","Array","isArray","arr2","_arrayWithoutHoles","iter","from","_iterableToArray","TypeError","_nonIterableSpread","reflectionIsSupported","Reflect","defineMetadata","getOwnMetadataKeys","copyReflectionMetadata","to","forwardMetadata","getOwnPropertyNames","forEach","propertyKey","metaKey","metadata","getOwnMetadata","hasProto","__proto__","collectDataFromConstructor","vm","Component","originalInit","_init","_this","keys","push","plainData","$internalHooks","componentFactory","arguments","_componentTag","proto","indexOf","descriptor","getOwnPropertyDescriptor","methods","mixins","computed","decorators","__decorators__","fn","superProto","getPrototypeOf","Super","Vue","Extended","extend","forwardStaticMembers","shouldIgnore","callee","caller","Original","extendedDescriptor","superDescriptor","registerHooks","apply"],"mappings":"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"}